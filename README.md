# Why I Include Non-Programming Projects

I don’t just ship code I design systems. My non-programming work (requirements, diagrams, case studies, threat models, network topologies, test plans) is the structure my code sits on. It shows how I frame problems, reason about trade-offs, and build ethical, secure, and reliable solutions across **ethics & society**, **networking**, **software engineering**, and **system design**.

---

## What I count as “non-programming”

* Problem framing: goals, stakeholders, constraints, risks
* Requirements: functional & non-functional, success criteria
* Models & diagrams: context, use-case, sequence/state, data flow, ERD
* Architecture: components, interfaces, deployment, SLIs/SLOs
* Network design: topology, IP plan, VLANs, routing, ACLs
* Security & ethics: threat models, privacy/fairness analysis
* Test plans: scenarios, expected results, acceptance criteria

---


## How I approach projects (before coding)

1. **Context & goals** (who, why, constraints, success metrics)
2. **Requirements** (functional + non-functional)
3. **Risks & ethics** (stakeholders, harms, mitigations; threat model)
4. **Models** (context, use-case, sequence/state, data model; for networks: topology/IP/VLAN/routing)
5. **Architecture** (components, interfaces, deployment, SLIs/SLOs)
6. **Test plan** (scenarios, inputs/outputs, acceptance)
7. **Implement** (code/config) and adjust docs if reality differs

